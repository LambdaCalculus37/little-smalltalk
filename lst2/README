.\" information on Little Smalltalk, version 2, beta release
.SH
General Overview
.PP
First, the obvious facts.  This is not Smalltalk-80, nor even Smalltalk-V.
This is the second version of the Little Smalltalk system, the first version
of which is described in the book recently published by Addison-Wesley*.
.FS
* \fIA Little Smalltalk\fP, by Timothy A. Budd.  Published by Addison
Wesley, 1987.  In better bookshops everywhere.
.FE
Version two is smaller and faster; does more in Smalltalk, not in C; and is
designed to be more portable to a wider variety of machines (we are working
on versions now for various PCs).  
.PP
My attitude towards the language has been
rather cavalier; what I liked I kept and what I didn't like I tossed out.
This is explained in more detail in my book and in the end of this note.
As a consequence, individuals familiar with ST-80 or ST-V will be struck 
by how much they are missing, and I make no apologies for this.  On the
other hand, you don't find ST-V posted to net.sources.  Among the features
you won't find here are metaclasses, class methods, windows, graphics 
support, and more.
.PP
What you will find is a small language that does give you the flavor of
object oriented programming at very little cost.  We are working to improve
the system, and hope to distribute new versions as we develop them, 
as well as porting it to a wide range of machines.
If you find (and preferably, fix!) bugs let us know.
If you make nice additions let us know.
If you want to make complements let us know.
If you want to make complaints let us know.
If you want support you just might be out of luck.
.PP
This software is entirely public domain.  You are encouraged to give it
to as many friends as you may have.  As a courtesy, I would appreciate it
if you left my name on the code as the author, but I make no other claims
to it (I also, of course, disavow any liability for any bizarre things you
may choose to do with it).  Enjoy.
.SH
Building the System
.PP
There are three steps involving in building the system; making the parser
(the component used to generate the initial object image), making the
bytecode interpreter, and making the object image.
.PP
After you have unbundled all the files, to create the parser type
.DS I
make parse
.DE
.PP
The resulting program, called parse, is used to generate the object image
initially loaded into the bytecode interpreter.
.PP
Next, make the interpreter itself by typing
.DS I
make st
.DE
.PP
Note that the interpreter and the parser share some files.
.PP
Finally, produce an initial object image.  The image created when you type
.DS I
make sunix
.DE
.LP
is the smallest and fastest.  It is a single process version of smalltalk.
A buggy multiprocess version can be created by typing ``make munix''*.
.FS
* Multi processing from munix is done entirely in Smalltalk.
While this is a good idea from the point of view of keeping the bytecode
interpreter small and giving one the greatest flexibility, there seems to
be a dramatic performance penalty.  I'm considering the alternatives.
.FE
Of more interest, an image containing test cases (***currently only
the 8 queens***) can be generated by typing ``make stest''.
In the latter case, the command ``test all'', when given in response to the
prompt (see below), runs all the test cases.
.PP
Once you have created an object image, type 
.DS I
st
.DE
.LP
to run the system.
By default the image file ``imageFile'' is read.  You can optionally
use a different image file by giving the name on the command line following
the st command.
.SH
Getting Started
.PP
When you start version two Little Smalltalk under Unix, you will be given a 
prompt.
You can enter expressions in response to the prompt, and the system will 
evaluate them (although it will not print the result unless you request it).
For example:
.DS I
>	(4 + 5) print
7
.DE
.PP
You can create a new global variable (a variable known every place, including
the command line) by simply inserting a command into the dictionary that
maintains the names of all global variables.  You use as key the name of
the new global variable (as a Symbol), and as value the initial value to 
be associated with the variable.
.DS I
>	globalNames at: #i put: 17
>	i print
17
.DE
.PP
Global variables cannot be modified by the assignment arrow.  In particular,
the following gives an error:
.DS I
>	i <- 16
Compiler error: unknown variable i
.DE
.PP
Global variables can, however, be used in expressions:
.DS I
>	(i + 3) print
20
.DE
.PP
The most common use for global variables is creating a new Class.  A Class
is simply a global variable, by convention (but only convention) being given
a name beginning with an uppercase letter.  For example:
.DS I
>	globalNames at: #Employee put: Class new
.DE
.PP
This creates a new class called \fBEmployee\fP, an instance of 
class \fBClass\fP.  Various messages, understood by instances of class
\fBClass\fP, can be used to initialize various features of this new object.
(This would be a good time to take a peek at the file ``basicclasses'', which
contains a textual description of all the methods used in the standard
classes.  Note carefully the methods used in class Class).
.DS I
>	globalNames superClass: Object
>	globalNames name: #Employee
>	globalNames variables: #(department salary)
.DE
.PP
The most important initializing message is \fBaddMethod\fP, which 
drops you into an editor (currently only \fIvi\fP), in which you enter
the body of a method.  When you exit the editor the method is compiled,
and either entered into the method dictionary for the class (if there
are no errors) or a sequence of error messages are displayed on the output
device.
.PP
To save an object image, type the command
.DS I
smalltalk saveImage
.DE
You will be prompted for the name of the image file.
.SH
Changes from Little Smalltalk version one
.PP
The following changes have been made from version one to version two:
.IP \(bu
The user interface is slightly different.  This is most apparent in the way
new classes are added (see above).
.IP \(bu
Much (very much) more of the system is now written in Smalltalk, rather
than C.  This allows the user to see, and modify it if they wish.
This also means that the virtual machine is now much smaller.
.IP \(bu
The pseudo variable selfProcess is no longer supported.
The variables true, false and nil are now treated as global variables, not
pseudo variables (see below).
There are plans for adding processes to version two, but they have not
been formalized yet.
.IP \(bu
Global variables are now supported; in fact classes are now simply global
variables, as are the variables true, false, smalltalk and nil.
The global variable globalNames contains the dictionary of all currently
known global variables and their values.
(Pool variables are still not supported).
.IP \(bu
The internal bytecodes are slightly different.  In particular, the bytecode
representing ``send to super'' has been eliminated, and a bytecode representing
``do a primitive'' has been added.
.IP \(bu
The Collection hierarchy has been rearranged.  The rational for this change
is explained in more detail in another essay.
(possibly not written yet).
.IP \(bu
Some methods, most notably the error message methods, have been moved out
of class Object and into class Smalltalk.
.IP \(bu
The syntax for primitives is different; the keyword \fBprimitive\fP has been
eliminated, and named primitives are now gone as well.
Fewer actions are performed by primitives, having been
replaced by Smalltalk methods.
.IP \(bu
Command line options, such as the fast load feature, have been eliminated.
However, since version two reads in a binary object image, not a textual
file, loading should be considerably faster.
.SH
Electronic Communication
.PP
Here is my address, various net addresses:
.DS I
Tim Budd
Oregon State University
Department of Computer Science
Corvallis, Oregon 97331 USA
(503) 754-3273

budd@oregon-state.csnet

{tektronix, hp-pcd} !orstcs!budd
.DE
.SH
Changes
.PP
I want to emphasize that this is not even a beta-test version (does that
make it an alpha or a gamma version?).  I will be making a number of
changes, hopefully just additions to the initial image, in the next
few months.  In addition, I hope to prepare versions for other machines,
notably the Macintosh and the IBM PC.  I am also encouraging others to
port the system to new machines.  If you have done so, please let me
know.
