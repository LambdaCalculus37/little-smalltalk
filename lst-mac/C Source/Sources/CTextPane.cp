//=============================================================================//	Little Smalltalk, version 3//	Written by Tim Budd, Oregon State University, July 1988////	Symantec Think Class Library interface code //		©Julian Barkway, April 1994, all rights reserved.////	CTextPane.cp//	------------//	This class implements a text-only pane.////	//	Version History//	---------------//	3.1.4 - First general release//	3.1.5 - Modified to support command-key equivalents for menu items//=============================================================================#include <string.h>#include "CTextPane.h"#include "Commands.h"#include "CLStDoc.h"#include "CLStWindow.h"#include "CBartender.h"#include "CLStApp.h"#include "Constants.h"#include <Global.h>#include "TCLUtilities.h"extern	CLStApp		*gSmalltalk;extern	CBartender	*gBartender;extern 	EventRecord  gLastMouseUp;extern 	CBureaucrat	*gGopher;	#define DOC_DIRTY	((CDocument *)itsSupervisor)->dirty//={OVERRIDE}==================================================================// Initialise a shiny new text pane object.//=============================================================================void CTextPane::ITextPane (CView *encl, CBureaucrat *super, 							SizingOption hSizing, SizingOption vSizing,							short lineLength){	Rect	margin = {4, 4, 0, 0};		IEditText      (encl, super, 1, 1, 0, 0, hSizing, vSizing, 2000);	FitToEnclosure (TRUE, TRUE);	ResizeFrame    (&margin);}//={OVERRIDE}==================================================================// Stop a click selecting text when it is combined with the option key.//=============================================================================void CTextPane::DoClick (Point hitPt, short modifierKeys, long when){ 		if (modifierKeys & optionKey)		return;	inherited::DoClick (hitPt, modifierKeys, when);		}//={OVERRIDE}==================================================================// Handle menu dimming for cut'n'paste and ensure TCL commands aren't sent to// Smalltalk.//=============================================================================void CTextPane::DoCommand (long aCmd){    if (aCmd == cmdPaste || aCmd == cmdCut)		if (! DOC_DIRTY) {			DOC_DIRTY = TRUE;			gBartender->EnableCmd (cmdSave);			gBartender->EnableCmd (cmdSaveAs);		}	gSmalltalk->smalltalkCmd = FALSE;	inherited::DoCommand (aCmd);	if (! gSmalltalk->smalltalkCmd) 		gSmalltalk->lastEvent.what = 0;}//={OVERRIDE}==================================================================// Ensure doc is set to be saved when an alphanumeric key has been pressed// v3.1.5: Ensure command key equivalents are processed//=============================================================================void CTextPane::DoKeyDown (char ch, Byte keyCde, EventRecord *event){    inherited::DoKeyDown (ch, keyCde, event);    switch (keyCde) {        case KeyHome:        case KeyEnd:        case KeyPageUp:        case KeyPageDown:            break;        default: 			if (! DOC_DIRTY) {				DOC_DIRTY = TRUE;				gBartender->EnableCmd (cmdSave);				gBartender->EnableCmd (cmdSaveAs);			}            break;    }}//={OVERRIDE}==================================================================// Handle auto repeat//=============================================================================void CTextPane::DoAutoKey (char ch, Byte keyCde, EventRecord *event){    inherited::DoAutoKey (ch, keyCde, event);    switch (keyCde) {        case KeyHome:        case KeyEnd:        case KeyPageUp:        case KeyPageDown:            break;        default:  			if (! DOC_DIRTY) {				DOC_DIRTY = TRUE;				gBartender->EnableCmd (cmdSave);				gBartender->EnableCmd (cmdSaveAs);			}            break;    }}//={OVERRIDE}==================================================================// Ensure correct action taken if new insertion will take TE to >32k.//=============================================================================void CTextPane::CheckInsertion (long insertLen, Boolean useSelection){	long		newLen, growSize;	short		ln, svSelStart, svSelEnd, newSelEnd;	Handle		hdl;		newLen = (**macTE).teLength + insertLen;		if (useSelection)		newLen -= (**macTE).selEnd - (**macTE).selStart;		if (newLen > kMaxTELength) {		svSelStart = (**macTE).selStart;		svSelEnd   = (**macTE).selEnd;		newSelEnd  = insertLen;		ln = FindLine (newSelEnd);	// Ensure we're deleting a full line		newSelEnd = (**macTE).lineStarts [ln + 1];		SetSelection (0, newSelEnd, FALSE);		TEDelete (macTE);		SetSelection (svSelStart, svSelEnd, FALSE);	}// Either delete enough from the top to make the insertion fit or post a recoverable // error, depending on the parameters for this pane. At the moment, will always delete// from top. Shouldn't be editing big files in Little Smalltalk anyway....//***Failure (paramErr, excExceedTELimit);	// Don't fail for now			growSize = newLen - (**macTE).teLength;			// check for available memory	if (growSize > 0) {		hdl = NewHandleCanFail (growSize);		FailNIL      (hdl);		DisposHandle (hdl);	}}//=============================================================================// Replace the current contents of the text pane with theText.// Parameter changed type to Handle for v3.1.5 to provide better sizing for// TEInsert ().//=============================================================================void CTextPane::ReplaceContents (Handle theText){	Prepare 	();	TESetSelect	(0L, 32767L, macTE);	TEDelete	(macTE);	TEInsert	((char *)*theText, GetHandleSize (theText), macTE);}//=============================================================================// Completely delete the current contents of the text pane.//=============================================================================void CTextPane::DeleteContents (void){	Prepare 	();	TESetSelect	(0L, 32767L, macTE);	TEDelete	(macTE);}