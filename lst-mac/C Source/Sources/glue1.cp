/*	Little Smalltalk, version 3	Written by Tim Budd, Oregon State University, June 1988	Symantec Think Class Library interface code 		©Julian Barkway, April 1994, all rights reserved. 		glue1.cp 	--------		This is the interface between Little Smalltalk and the Symantec Think 	Class Library (v1.1.3). Where possible, I have retained the StdWin 	function names and parameters used in the original Little Smalltalk (v3) 	(although certain structures now refer to TCL objects) in order to assist 	porting. 		Glue1.cp contains functions relating to windows, menus, graphics and dialogues.	Glue2.cp contains text, event handling and general purpose functions.		Version History	---------------	3.1.4 - First general release	3.1.5 - Modified to allow specification of non-closeable windows (wopentosize() only)	        Modified to allow command key shortcuts for menu options*/#include <stdlib.h>#include <stdio.h>#include <string.h>#include "Callbacks.proto.h"#include "TBUtilities.h"#include "Constants.h"#include "Global.h"#include "CBartender.h"#include "CLStWindow.h"#include "CLStApp.h"#include "CLStDoc.h"#include "CGraphicsPane.h"#include "LStResources.h"#include "env.h"#include "memory.h"#include "macio.h"#include "tclprim.proto.h"					// 'class' was redefined as 'klass' in order to avoid conflicts 					// with the synonymous Think-C reserved word. Now the new definition 					// must be removed in order to use TCL functions...#undef class#include "glue.h"extern CBartender	*gBartender;extern CLStApp		*gSmalltalk;#define uchar	unsigned char//===================================================================================// Initialise the host windowing facility.//===================================================================================void winit (void){	gSmalltalk = new (CLStApp);	gSmalltalk->ILStApp ();	if (gSystem.systemVersion < 0x0700) {		wperror ("Sorry, but System-7 or later is required to run Little Smalltalk.");		abort ();	}}//===================================================================================// Return the current version number as a 'C' string.//===================================================================================void getVersionNumber (char *str){	PtoCstr (gSmalltalk->versionStr);	strcpy  (str, gSmalltalk->versionStr);	CtoPstr (gSmalltalk->versionStr);}//===================================================================================// Perform any necessary shut-down protocol for the host windowing facility.//===================================================================================void wdone (void){	return;}//===================================================================================// Display a message to the user.//===================================================================================void wmessage (char *prompt){	gSmalltalk->DoMessageAlert (prompt);}//===================================================================================// Display an error alert to the user.//===================================================================================void wperror (char *name){	CtoPstr        (name);	ParamText      ((uchar *)name, NULL, NULL, NULL);	PositionDialog ('ALRT', ALRTgeneral);	InitCursor     ();	Alert          (ALRTgeneral, NULL);	PtoCstr        ((uchar *)name);}//=====================================================================================// Put up a prompt requesting some text from the user.//=====================================================================================Boolean waskstr (char *prompt, char *buf, int len){	DialogPtr			theDialog;	GrafPtr				savePort;	short				itemHit, iType;	Handle				iText;	Rect				iRect;	Str255				boxText;	Boolean				rc;			GetPort (&savePort);	theDialog = GetNewDialog (kAskStringDLOG, 0L, (WindowPtr)-1L);	if (!theDialog) {		SetPort (savePort);		return (FALSE);	}	CtoPstr   (prompt);	ParamText ((uchar *)prompt, NULL, NULL, NULL);		GetDItem (theDialog, 5, &iType, &iText, &iRect);	SetDItem (theDialog, 5, iType, (Handle)highlightButton, &iRect);	GetDItem (theDialog, 4, &iType, &iText, &iRect);		while (itemHit != OK && itemHit != Cancel) {	    ModalDialog (defaultButtonFilter, &itemHit );	}	if (itemHit == Cancel)		rc = FALSE;	else {		GetIText (iText, boxText); 		PtoCstr (boxText);		strcpy (buf, (char *)boxText);				rc = TRUE;	}		DisposDialog (theDialog);	SetPort      (savePort);	PtoCstr      ((uchar *)prompt);	return rc;}//===================================================================================// Display a message to the user requiring a Yes, No or Cancel response.//===================================================================================int waskync	(char *prompt, int def){	return ((int)gSmalltalk->DoYNCAlert (prompt));}//===================================================================================// Display the standard file name requester. // ---Parameter ftype added to StdWin function prototype.//===================================================================================Boolean waskfile (char *prompt, char *buf, int len, Boolean newFile, short ftype){	WindowRecord		*w;	CLStWindow			*stWin;	CLStDoc				*doc;	StandardFileReply	fileStuff;	SFTypeList			fileTypes;	short				numTypes = 1;	w = (WindowRecord *)FrontWindow ();	if (! w)		doc = new (CLStDoc);	else {		stWin = (CLStWindow *)GetWRefCon ((WindowPtr)w);		doc   = (CLStDoc *)(stWin->theLStWindow)->document;	}		if (newFile)		doc->AskFileName (prompt, newFile, &fileStuff, NULL, 0);	else {			stFileTypeToMac (ftype, fileTypes [0]);		if (fileTypes [0] == 0L) {			numTypes = -1;	/* If type not specified, then don't apply filtering */			doc->AskFileName (prompt, newFile, &fileStuff, NULL, numTypes);		}		else			doc->AskFileName (prompt, newFile, &fileStuff, fileTypes, numTypes);	}	if (fileStuff.sfGood == FALSE) 		return FALSE;		PtoCstr     (fileStuff.sfFile.name);	getPathName (fileStuff.sfFile.vRefNum, fileStuff.sfFile.parID, buf);	strcat      (buf, (char *)fileStuff.sfFile.name);	return TRUE;}//===================================================================================// Enable (un-dim) an entire menu//===================================================================================void wmenuenable (MENU *mp, int item, int flag){	if (flag)		EnableItem ((MenuHandle)mp, item + 1);	else		DisableItem ((MenuHandle)mp, item + 1);}//===================================================================================// Create a new menu.//===================================================================================MENU *wmenucreate (int id, char *title){	MenuHandle		mh;		id += kSTMenuBase;	// Our MENU resource ids start at 50. Smalltalk uses 1 - 15						// Unfortunately, TCL also uses 1 - 5, hence this kludge.	gBartender->AddMenu (id, FALSE, 0);	((CBartender *)gBartender)->SetDimOption (id, dimNONE);	mh = gBartender->FindMacMenu (id);	(*mh)->menuID = id;	return (MenuPtr)mh;}//===================================================================================// Create a pop-up menu. Pop-up menus are not handled through TCL and are created// without the need for a resource file entry.//===================================================================================MENU *popUpMenuCreate (short menuID){	menuID += kSTPopMenuBase;	return (MenuPtr)NewMenu (menuID, "\p");}//===================================================================================// Attach a menu to a window.//===================================================================================void wmenuattach (WINDOW *win, MENU *mp){	MenuHandle	mh;	short		menuID;		mh     = (MenuHandle)mp;	menuID = (*mh)->menuID;	((CBartender *)gBartender)->InsertInBar (menuID, 0);}//===================================================================================// Detach a menu from a window.//===================================================================================void wmenudetach (WINDOW *win, MENU *mp){	MenuHandle	mh;	short		menuID;		mh     = (MenuHandle)mp;	menuID = (*mh)->menuID;	gBartender->DeleteFromBar (menuID);}//===================================================================================// Check mark an item.//===================================================================================void wmenucheck	(MENU *mp, int item, int flag){	CheckItem ((MenuHandle)mp, item + 1, flag);}//===================================================================================// Stub function for StdWin compatibility.//===================================================================================void wmenusetdeflocal (Boolean local){	return;}//===================================================================================// Append an item to the end of a menu.// Modified to process command-key shortcuts (v3.1.5)//===================================================================================int wmenuadditem (MENU *mp, char *text, int shortcut){	char	str [2] = {0, 0};		if (shortcut && shortcut > 0) {		str [0] = (char)shortcut;		strcat (text, "/");		strcat (text, str);	}	CtoPstr (text);	AppendMenu ((MenuHandle)mp, (uchar *)text);	PtoCstr ((uchar *)text);	return (1);}//===================================================================================// Select an item from a pop-up menu displayed at top, left.  Not a StdWin function. //===================================================================================void selectFromPopUpMenu (MENU *mp, short top, short left, short *menu, short *item){	MenuHandle	mh;	long		selection;	Point		p;	mh = (MenuHandle)mp;	p.h = left;	p.v = top;	((CLStWindow *)GetWRefCon (FrontWindow () ))->Prepare ();	LocalToGlobal (&p);	InsertMenu (mh, hierMenu);	selection = PopUpMenuSelect (mh, p.v, p.h, 1);	if (HiWord (selection ) == 0)		*menu = *item = 0;	else {		*menu = HiWord (selection);		*item = LoWord (selection);	}		}//===================================================================================// Completely dispose of a menu.//===================================================================================void wmenudelete (MENU *mp){	MenuHandle	mh;	short		menuID;		mh     = (MenuHandle)mp;	menuID = (*mh)->menuID;	gBartender->RemoveMenu (menuID);}//===================================================================================// Remove a menu item.//===================================================================================void removeMenuItem (MENU *mp, short menuItem){	DelMenuItem ((MenuHandle)mp, menuItem);}//===================================================================================// Return four values representing the pixel co-ords of the left, top, right and // bottom of the maximum available screen are respectively.//===================================================================================void getMaxScreenArea (short *left, short *top, short *right, short *bottom){	*left   = screenBits.bounds.left;	*top    = screenBits.bounds.top;	*right  = screenBits.bounds.right;	*bottom = screenBits.bounds.bottom;}//===================================================================================// Return the named cursor from a resource or the system. //===================================================================================CURSOR *wfetchcursor (char *name){	CursHandle csrH;		if (strcmp (name, "ibeam") == 0)		csrH = GetCursor (iBeamCursor);	else if (strcmp (name, "cross") == 0)		csrH = GetCursor (crossCursor);	else if (strcmp (name, "plus") == 0)		csrH = GetCursor (plusCursor);	else if (strcmp (name, "watch") == 0)		csrH = GetCursor (watchCursor);	else if (strcmp (name, "arrow") == 0)		csrH = (CursHandle)0xffffffffL;	/* A fairly unlikely handle. We'll use it as a flag. */	else		csrH = (CursHandle) GetNamedResource ('CURS', (uchar *)name);		return (CURSOR *)csrH;}//===================================================================================// Set the current cursor to the given cursor. (Window is irrelevant here).//===================================================================================void wsetwincursor (WINDOW *win, CURSOR *cursor){	Cursor	csr;		if ((long)cursor == 0xffffffffL) {		InitCursor ();		return;	}		HLock ((Handle)cursor);	csr = **((CursHandle)cursor);	HUnlock ((Handle)cursor);	SetCursor (&csr);}//===================================================================================// Restore the standard arrow pointer.//===================================================================================void setArrowCursor (void){	InitCursor ();}//===================================================================================// Query the dirty status of a document.//===================================================================================Boolean docDirty (WINDOW *win){	return ((CDocument *)win->document)->dirty;}//===================================================================================// Change the size of the given document.//===================================================================================void wsetdocsize (WINDOW *win, int docwidth, int docheight){	((CLStWindow *)win->window)->ChangeSize (docwidth, docheight);}//===================================================================================// Mark the given window as active.//===================================================================================void wsetactive	(WINDOW *win){	((CLStWindow *)win->window)->Activate ();}//===================================================================================// Open a window. Note that drawproc is redundant.//===================================================================================WINDOW *wopen (char *title, void (*drawproc)(WINDOW *win, int top, int left,						 				     int bottom, int right) ){	CLStDoc	*doc;	WINDOW	*w;		w   = (WINDOW *)malloc ((size_t)sizeof (WINDOW));	w->document = (char *)new (CLStDoc);	((CLStDoc *)w->document)->ILStDoc (gSmalltalk, FALSE);	w->window   = (char *)((CLStDoc *)w->document)->BuildWindow (title, NULL, NULL, FALSE);	((CLStWindow *)w->window)->theLStWindow = w;	return w;}//===================================================================================// Open a window, given its location and size. Note: if the left, top and/or the// width/height parameter pairs are zero, values will be provided by the underlying// TCL routine.// Amended for v3.1.5 to allow specification of non-closeable windows.//===================================================================================WINDOW *wopentosize (char *title, int left, int top, int width, int height, Boolean noClose){	CLStDoc	*doc;	WINDOW	*w;	Point	wPosition, wSize, *p, *s;		w   = (WINDOW *)malloc ((size_t)sizeof (WINDOW));	w->document = (char *)new (CLStDoc);	((CLStDoc *)w->document)->ILStDoc (gSmalltalk, FALSE);	if (left == 0 && top == 0)		p = NULL;	else {		wPosition.h = left;		wPosition.v = top;		p           = &wPosition;	}	if (width == 0 && height == 0)		s = NULL;	else {		wSize.h     = width;		wSize.v     = height;		s           = &wSize;	}	w->window   = (char *)((CLStDoc *)w->document)->BuildWindow (title, p, s, noClose);	((CLStWindow *)w->window)->theLStWindow = w;	return w;}//===================================================================================// Close a window.//===================================================================================void wclose	(WINDOW *win){	((CLStWindow *)win->window)->Remove ();}//===================================================================================// Return the current size of a window.//===================================================================================void wgetwinsize (WINDOW *win, int *pwidth, int *pheight){	LongRect	lr;		((CLStWindow *)win->window)->GetAperture (&lr);	*pwidth  = lr.right - lr.left;	*pheight = lr.bottom - lr.top;}//===================================================================================// Return the current position (in global co-ordinates) of a window.//===================================================================================void wgetwinpos (WINDOW *win, int *h, int *v){	Point		pt;	GrafPort	*port;	port = ((CLStWindow *)(win->window))->macPort;	pt.h = port->portRect.left;	pt.v = port->portRect.top;	((CLStWindow *)(win->window))->Prepare ();	LocalToGlobal(&pt);	*h = pt.h;	*v = pt.v;}//===================================================================================// Bring a window to the 'front'.//===================================================================================void windowToFront (WINDOW *win){	((CLStWindow *)(win->window))->Select ();}//===================================================================================// Set a window's title.//===================================================================================void wsettitle (WINDOW *win, Str255 title){	((CLStWindow *)win->window)->SetTitle (title);}//===================================================================================// Stub function provided for StdWin compatitbility.//===================================================================================void wsetorigin (WINDOW *win, int orgh, int orgv){	return;}//===================================================================================// Notify the system that we wish to commence a drawing operation.// - Slightly altered from the StdWin prototype to enable drawing to be //   directed to a specific pane.//===================================================================================void wbegindrawing (TEXTEDIT *pane){	((CPane *)pane)->Prepare ();}//===================================================================================// Stub function provided for StdWin compatitbility.//===================================================================================void wenddrawing (TEXTEDIT *pane){	return;}//===================================================================================// Beep the beeper.//===================================================================================void wfleep	(void){	SysBeep (0);}//===================================================================================// Set the shading pattern for future drawing calls.//// Note: behaviour changed from StdWin prototype. Will now set the percentage//       of grey to be used in all drawing operations. Use wpaint () to colour//       a rectangle with the current pattern. This allows rather more flexibility.////       5 percentage ranges are allowed corresponding to the five predefined //       Mac Toolbox 'colours' as follows:////        0 - 19% = white//       20 - 39% = ltGray//       40 - 59% = gray//       60 - 79% = dkGray//       80%+     = black//===================================================================================void wshade	(int left, int top, int right, int bottom, int perc){	PatPtr	pat;		if (perc >= 0 && perc < 20) {		pat = (PatPtr)white;	}	else if (perc > 20 && perc < 39) {		pat = (PatPtr)ltGray;	}	else if (perc > 40 && perc < 59) {		pat = (PatPtr)gray;	}	else if (perc > 60 && perc < 79) {		pat = (PatPtr)dkGray;	}	else {		pat = (PatPtr)black;	}	PenPat ((uchar const *)pat);}//===================================================================================// Erase the given rectangle.//===================================================================================void werase (int left, int top, int right, int bottom){	Rect	r;		SetRect 	(&r, left, top, right, bottom);	EraseRect	(&r);}//===================================================================================// Draw a circle.//===================================================================================void wdrawcircle (int h, int v, int radius){	Rect	r;		SetRect 	(&r, h - radius, v - radius, h + radius, v + radius);	FrameOval	(&r);}//===================================================================================// Draw a line from the current pen position to the given co-ordinates.//===================================================================================void drawLineTo (int h, int v){	LineTo (h, v);}//===================================================================================// Move the pen position to the given co-ordinates.//===================================================================================void moveTo (short h, short v){	MoveTo (h, v);}//===================================================================================// Draw a pixel at the given co-ordinates.//===================================================================================void drawPixel (short h, short v){	MoveTo (h, v);	LineTo (h, v);}//===================================================================================// Draw a box corresponding to the given co-ordinates.//===================================================================================void wdrawbox (int left, int top, int right, int bottom){	Rect	r;		SetRect 	(&r, left, top, right, bottom);	FrameRect	(&r);}//===================================================================================// Invert all the pixels in a rectangular area.//===================================================================================void winvert (int left, int top, int right, int bottom){	Rect	r;		SetRect 	(&r, left, top, right, bottom);	InvertRect	(&r);}//===================================================================================// Fill a rectangle with the current pattern.//===================================================================================void wpaint	(int left, int top, int right, int bottom){	Rect	r;		SetRect 	(&r, left, top, right, bottom);	PaintRect	(&r);}//===================================================================================// Draw a character string at the given location.//===================================================================================void wdrawtext (int h, int v, char *str, int len){	MoveTo		(h, v);	DrawText	(str, 0, len);}//===================================================================================// Draw a single character at the given location.//===================================================================================void wdrawchar (int h, int v, int c){	MoveTo		(h, v);	DrawChar	((char)c);}